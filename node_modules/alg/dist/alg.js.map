{"version":3,"sources":["webpack://alg/webpack/universalModuleDefinition","webpack://alg/webpack/bootstrap","webpack://alg/./src/index.ts","webpack://alg/./src/algorithm/index.ts","webpack://alg/./src/algorithm/alg-part.ts","webpack://alg/./src/debug.ts","webpack://alg/./src/algorithm/block-move.ts","webpack://alg/./src/traversal.ts","webpack://alg/./src/example.ts","webpack://alg/./src/json.ts","webpack://alg/./src/parser.ts","webpack://alg/./src/jison_parser/index.js","webpack://alg/./src/validation.ts","webpack://alg/./src/keyboard.ts","webpack://alg/./src/url.ts"],"names":[],"mappings":"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C,CAAC,CAAC;AACnD,CAAC;;;;;;;ACvBD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,YAAY,IAAI,WAAW,SAAS;AACvE,cAAc,0BAA0B,EAAE;AAC1C,MAAM;AACN,WAAW,4gBAA4gB;AACvhB,aAAa,wPAAwP;AACrQ;AACA;AACA;;AAEA;AACA;AACA;AACA,iB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,kBAAkB;AAClB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,CAAC;AACD,0CAA0C,yBAAyB,GAAG,MAAM,EAAE,QAAQ,EAAE,SAAS,eAAe,yGAAyG,aAAa,aAAa,GAAG,QAAQ,YAAY,gBAAgB,gBAAgB,wCAAwC,8BAA8B,qGAAqG,gBAAgB,6BAA6B,gGAAgG,kBAAkB,qCAAqC,kBAAkB,2CAA2C,uBAAuB,sEAAsE,kHAAkH,gBAAgB,qGAAqG,gBAAgB,wCAAwC,6BAA6B,UAAU,2DAA2D,oBAAoB,EAAE,UAAU,gBAAgB,WAAW,eAAe,wCAAwC,gBAAgB,wCAAwC,0BAA0B,kBAAkB,aAAa,kBAAkB,iBAAiB,aAAa,EAAE,UAAU,EAAE,UAAU;AAC/9C,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL,qDAAqD;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,aAAa,WAAW;AACxB,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,CAAC;;;AAGD,IAAI,IAAgE;AACpE;AACA;AACA,6BAA6B,4CAA4C;AACzE;;;;;;;;ACrqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AAEhC,qBAAsB,SAAQ,KAAK;CAAG;AAEtC,wBAAkC,SAAQ,sDAAiB;CAAG;AAIrE,wBAAwB,MAAc,EAAE,kBAAgC;IACtE,KAAK,MAAM,IAAI,IAAI,kBAAkB,EAAE;QACrC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE;YACzB,OAAO,IAAI,CAAC;SACb;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,yBAAyB;AACzB,IAAI,iBAAiB,GAAe;IAClC,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;IACT,GAAG,EAAE,IAAI;CACV;AAED,IAAI,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","file":"alg.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alg\"] = factory();\n\telse\n\t\troot[\"alg\"] = factory();\n})(typeof self !== \"undefined\" ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export {\n  AlgPart,\n  Unit,\n  WithAmount,\n  Move,\n  Container,\n  Annotation,\n  Sequence,\n  Group,\n  MoveFamily,\n  BlockMove,\n  BareBlockMove,\n  LayerBlockMove,\n  RangeBlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nexport {\n  TraversalDownUp,\n  TraversalUp,\n  invert,\n  expand,\n  structureEquals,\n  coalesceBaseMoves,\n  algToString\n} from \"./traversal\";\n\nexport {\n  Example\n} from \"./example\"\n\nexport {\n  AlgJSON,\n  fromJSON\n} from \"./json\"\n\nexport {\n  parse\n } from \"./parser\"\n\nexport {\n  keyToMove\n} from \"./keyboard\"\n\nexport {\n  validateSiGNMoves,\n  validateFlatAlg,\n  validateSiGNAlg,\n  ValidationError\n} from \"./validation\"\n\nexport {\n  serializeURLParam,\n  deserializeURLParam,\n  algCubingNetLink,\n  getAlgURLParam\n} from \"./url\"\n\nexport {\n  setAlgPartTypeMismatchReportingLevel\n} from \"./debug\"","export {\n  AlgPartType,\n  AlgPart,\n  Unit,\n  Move,\n  Annotation,\n  Container,\n  WithAmount,\n  Sequence,\n  Group,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./alg-part\";\n\nexport {\n  MoveFamily,\n  BlockMove,\n  BareBlockMove,\n  LayerBlockMove,\n  RangeBlockMove\n} from \"./block-move\";\n","import {reportTypeMismatch} from \"../debug\"\n\nexport type AlgPartType = string;\n\nexport abstract class AlgPart {\n  abstract type: AlgPartType;\n}\n\n// type Constructor<T> = Function & { prototype: T }\nexport function matchesAlgType<T extends AlgPart>(a: any, t: AlgPartType): boolean {\n  return a.type == t\n}\n\nexport function assertMatchesType<T extends AlgPart>(a: any, t: AlgPartType): T {\n  if (!matchesAlgType(a, t)) {\n    reportTypeMismatch(`Expected \"type\": \"${t}\", saw \"type\": \\\"${a.type}\\\".`);\n  }\n  return a;\n}\n\n// Assumes that every `AlgPart` is a `Unit` or a `Sequence`.\nexport function isUnit(a: AlgPart): boolean {\n  if (!(\"type\" in a)) {\n    return false\n  }\n  return !matchesAlgType(a, \"sequence\");\n}\n\nexport function assertIsUnit(a: AlgPart): Unit {\n  if (!(\"type\" in a)) {\n    reportTypeMismatch(`Expected \"unit\", saw a value that was not an AlgPart.`);\n  }\n  if (matchesAlgType(a, \"sequence\")) {\n    reportTypeMismatch(`Expected unit, saw \"sequence\".`);\n  }\n  return a;\n}\n\nexport abstract class Unit extends AlgPart {}\n\nexport abstract class Move extends Unit {}\nexport abstract class Annotation extends Unit {}\nexport abstract class Container extends Unit {}\n\n// TODO: Reintroduce an Algorithm class, and allow a mutable sequence too?\nexport class Sequence extends AlgPart {\n  public type: string = \"sequence\";\n  constructor(public nestedUnits: Unit[]) {\n    super();\n    for (const n of nestedUnits) {\n      assertIsUnit(n);\n    }\n    Object.freeze(this.nestedUnits);\n    Object.freeze(this);\n  }\n}\n\nexport interface WithAmount {\n  // TODO: Allow `amount` to be `undefined`, to distinguish between R and R1?\n  amount: number;\n}\nexport class Group extends Container implements WithAmount {\n  public type: string = \"group\";\n  constructor(public nestedSequence: Sequence, public amount: number=1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Commutator extends Container implements WithAmount {\n  public type: string = \"commutator\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number=1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Conjugate extends Container implements WithAmount {\n  public type: string = \"conjugate\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number=1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Pause extends Move {\n  public type: string = \"pause\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class NewLine extends Annotation {\n  public type: string = \"newLine\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO: must be followed by a newline, unless at the end of an alg?\nexport class CommentShort extends Annotation {\n  public type: string = \"commentShort\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class CommentLong extends Annotation {\n  public type: string = \"commentLong\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO\n// export class TimeStamp extends AlgPart implements AlgPart\n","type ReportingLevel = \"none\" | \"warn\" | \"error\"\nvar currentReportingLevel = \"warn\";\n\nvar MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nvar numWarned = 0;\n\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw msg;\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned +1 == MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(level: ReportingLevel): void {\n  currentReportingLevel = level;\n}","import {Move} from \"./alg-part\"\n\nexport type MoveFamily = string; // TODO: Convert to an enum with string mappings.\n\n// TODO: Rename to `LetterMove`?\nexport class BlockMove extends Move {\n  public type: string = \"blockMove\";\n\n  // If `outerLayer` is set, `innerLayer` must also be set.\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(outerLayer: number | undefined, innerLayer: number | undefined, public family: MoveFamily, public amount: number=1) {\n    super();\n    this.outerLayer = outerLayer;\n    this.innerLayer = innerLayer;\n    Object.freeze(this);\n  }\n}\n\nexport function BareBlockMove(family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, undefined, family, amount);\n}\n\nexport function LayerBlockMove(innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, innerLayer, family, amount);\n}\n\nexport function RangeBlockMove(outerLayer: number,innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(outerLayer, innerLayer, family, amount);\n}\n","import {matchesAlgType, assertMatchesType, isUnit, assertIsUnit} from \"./algorithm/alg-part\"\n\nimport {\n  AlgPart,\n  Unit,\n  Sequence,\n  Group,\n  BlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong,\n  WithAmount\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(t: TraversalDownUp<DataDown, DataUp>, algPart: AlgPart, dataDown: DataDown): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      assertMatchesType(algPart, \"sequence\");\n      return t.traverseSequence(<Sequence >algPart, dataDown);\n    case \"group\":\n      assertMatchesType(algPart, \"group\");\n      return t.traverseGroup(<Group >algPart, dataDown);\n    case \"blockMove\":\n      assertMatchesType(algPart, \"blockMove\");\n      return t.traverseBlockMove(<BlockMove >algPart, dataDown);\n    case \"commutator\":\n      assertMatchesType(algPart, \"commutator\");\n      return t.traverseCommutator (<Commutator>algPart, dataDown);\n    case \"conjugate\":\n      assertMatchesType(algPart, \"conjugate\");\n      return t.traverseConjugate(<Conjugate >algPart, dataDown);\n    case \"pause\":\n      assertMatchesType(algPart, \"pause\");\n      return t.traversePause(<Pause>algPart, dataDown);\n    case \"newLine\":\n      assertMatchesType(algPart, \"newLine\");\n      return t.traverseNewLine(<NewLine >algPart, dataDown);\n    case \"commentShort\":\n      assertMatchesType(algPart, \"commentShort\");\n      return t.traverseCommentShort (<CommentShort>algPart, dataDown);\n    case \"commentLong\":\n      assertMatchesType(algPart, \"commentLong\");\n      return t.traverseCommentLong (<CommentLong>algPart, dataDown);\n    default: \n      throw `Unknown AlgPart type: ${algPart.type}`\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    return assertIsUnit(<any>this.traverse(algPart, dataDown));\n  }\n\n  public abstract traverseSequence(sequence: Sequence, dataDown: DataDown): DataUp;\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove, dataDown: DataDown): DataUp;\n  public abstract traverseCommutator(commutator: Commutator, dataDown: DataDown): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate, dataDown: DataDown): DataUp;\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort, dataDown: DataDown): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<undefined, DataUp> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    return assertIsUnit(<any>this.traverse(algPart));\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong): DataUp;\n};\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(sequence.nestedUnits.slice().reverse().map(a => this.traverseIntoUnit(a)));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return new BlockMove(blockMove.outerLayer, blockMove.innerLayer, blockMove.family, -blockMove.amount);\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(conjugate.A, this.traverseSequence(conjugate.B), conjugate.amount);\n  }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    var flattened: Unit[] = [];\n    for (const part of algList) {\n      if (matchesAlgType(part, \"sequence\")) {\n        flattened = flattened.concat((part as Sequence).nestedUnits);\n      } else if (isUnit(part)) {\n        flattened.push(part)\n      } else {\n        throw \"expand() encountered an internal error. Did you pass in a valid Algorithm?\"\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: WithAmount): Sequence {\n    var amount = Math.abs(accordingTo.amount);\n    var amountDir = (accordingTo.amount > 0) ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    var once: Unit[];\n    if (amountDir == -1) {\n      // TODO: Avoid casting to sequence.\n      once = (<Sequence>(invert(new Sequence(algList)))).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    var repeated: Unit[] = [];\n    for (var i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(this.flattenSequenceOneLevel(sequence.nestedUnits.map(a => this.traverse(a))));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]), group);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    var expandedA = this.traverseSequence(commutator.A)\n    var expandedB = this.traverseSequence(commutator.B)\n    var once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB)\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    var expandedA = this.traverseSequence(conjugate.A)\n    var expandedB = this.traverseSequence(conjugate.B)\n    var once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA)\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (isUnit(dataDown)) {\n      return false;\n    }\n    const dataDownSeq = dataDown as Sequence;\n    if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) {\n      return false;\n    }\n    for (var i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Group) && this.traverse(group.nestedSequence, dataDown.nestedSequence);\n  }\n  public traverseBlockMove(blockMove: BlockMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return dataDown instanceof BlockMove &&\n           blockMove.outerLayer === dataDown.outerLayer &&\n           blockMove.innerLayer === dataDown.innerLayer &&\n           blockMove.family === dataDown.family &&\n           blockMove.amount === dataDown.amount;\n  }\n  public traverseCommutator(commutator: Commutator, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Commutator) &&\n           this.traverse(commutator.A, dataDown.A) &&\n           this.traverse(commutator.B, dataDown.B);\n  }\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Conjugate) &&\n           this.traverse(conjugate.A, dataDown.A) &&\n           this.traverse(conjugate.B, dataDown.B);\n  }\n  public traversePause(pause: Pause, dataDown: AlgPart): boolean {\n    return dataDown instanceof Pause;\n  }\n  public traverseNewLine(newLine: NewLine, dataDown: AlgPart): boolean {\n    return dataDown instanceof NewLine;\n  }\n  public traverseCommentShort(commentShort: CommentShort, dataDown: AlgPart): boolean {\n    return (dataDown instanceof CommentShort) && (commentShort.comment == dataDown.comment);\n  }\n  public traverseCommentLong(commentLong: CommentLong, dataDown: AlgPart): boolean {\n    return (dataDown instanceof CommentLong) && (commentLong.comment == dataDown.comment);\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n  private sameBlock(moveA: BlockMove, moveB: BlockMove): boolean {\n    // TODO: Handle layers\n    return moveA.outerLayer === moveB.outerLayer &&\n           moveA.innerLayer === moveB.innerLayer &&\n           moveA.family === moveB.family;\n  }\n\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    var coalesced: Unit[] = [];\n    for (const part of sequence.nestedUnits) {\n      if (!(part instanceof BlockMove)) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        var last = coalesced[coalesced.length-1];\n        if (last instanceof BlockMove &&\n            this.sameBlock(last, part)) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          var amount = last.amount + part.amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(new BlockMove(part.outerLayer, part.innerLayer, part.family, amount));\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n  public traverseGroup(group: Group):                      AlgPart { return group; }\n  public traverseBlockMove(blockMove: BlockMove):             AlgPart { return blockMove; }\n  public traverseCommutator(commutator: Commutator):       AlgPart { return commutator; }\n  public traverseConjugate(conjugate: Conjugate):          AlgPart { return conjugate; }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Algorithm[], B: Algorithm): Sequence {\n//     var nestedAlgs: Algorithm[] = A.slice();\n//     if (B instanceof Sequence) {\n//       nestedAlgs = nestedAlgs.concat(B.nestedUnits)\n//     } else {\n//       nestedAlgs.push(B);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseBlockMove(    BlockMove:    BlockMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([BlockMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseCommentShort( commentShort: CommentShort, dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentShort]   , dataDown); }\n//   public traverseCommentLong(  commentLong:  CommentLong,  dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentLong]    , dataDown); }\n// }\n\nexport class ToString extends TraversalUp<string> {\n  private repetitionSuffix(amount: number): string {\n    var absAmount = Math.abs(amount);\n    var s = \"\";\n    if (absAmount !== 1) {\n      s += String(absAmount)\n    }\n    if (absAmount !== amount) {\n      s += \"'\"\n    }\n    return s;\n  }\n\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (u1 instanceof Pause && u2 instanceof Pause) {\n      return \"\"\n    }\n    return \" \"\n  }\n\n  public traverseSequence(sequence: Sequence): string {\n    var output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (var i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(sequence.nestedUnits[i-1], sequence.nestedUnits[i]);\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n  public traverseGroup(        group:        Group       ): string { return \"(\" + this.traverse(group.nestedSequence) + \")\" + this.repetitionSuffix(group.amount); }\n  public traverseBlockMove(     blockMove:     BlockMove    ): string {\n    var out = blockMove.family + this.repetitionSuffix(blockMove.amount);\n    if (typeof blockMove.innerLayer !== \"undefined\") {\n      out = String(blockMove.innerLayer) + out;\n      if (typeof blockMove.outerLayer !== \"undefined\") {\n        out = String(blockMove.outerLayer) + \"-\" + out;\n      }\n    }\n    return out;\n  }\n  public traverseCommutator(   commutator:   Commutator  ): string { return \"[\" + this.traverse(commutator.A) + \", \" + this.traverse(commutator.B) + \"]\" + this.repetitionSuffix(commutator.amount); }\n  public traverseConjugate(    conjugate:    Conjugate   ): string { return \"[\" + this.traverse(conjugate.A) + \": \" + this.traverse(conjugate.B) + \"]\" + this.repetitionSuffix(conjugate.amount); }\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(        pause:        Pause       ): string { return \".\"; }\n  public traverseNewLine(      newLine:      NewLine     ): string { return \"\\n\"; }\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseCommentShort( commentShort: CommentShort): string { return \"//\" + commentShort.comment; }\n    // TODO: Sanitize `*/`\n  public traverseCommentLong(  commentLong:  CommentLong ): string { return \"/*\" + commentLong.comment + \"*/\"; }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert            = <(a: Sequence) => Sequence>invertInstance.traverseSequence.bind(invertInstance)\nexport const expand            = <(a: Sequence) => Sequence>expandInstance.traverseSequence.bind(expandInstance);\nexport const structureEquals   = <(a1: Sequence, a2: Sequence) => boolean>structureEqualsInstance.traverseSequence.bind(structureEqualsInstance);\nexport const coalesceBaseMoves = <(a: Sequence) => Sequence>coalesceBaseMovesInstance.traverseSequence.bind(coalesceBaseMovesInstance);\nexport const algToString       = <(a: Sequence) => string>algToStringInstance.traverseSequence.bind(algToStringInstance);\n\nexport const algPartStructureEqualsForTesting = <(a1: AlgPart, a2: AlgPart) => boolean>algToStringInstance.traverse.bind(algToStringInstance);\nexport const algPartToStringForTesting = <(a: AlgPart) => Sequence>algToStringInstance.traverse.bind(algToStringInstance);\n","import {\n  AlgPart,\n  Sequence,\n  Group,\n  BareBlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nexport namespace Example {\n\n  export const Sune: Sequence = new Sequence([\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\",  1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\",  1),\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\", -2),\n    BareBlockMove(\"R\", -1)\n  ]);\n\n  export const AntiSune: Sequence = new Sequence([\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\",  2),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1)\n  ]);\n\n  export const SuneCommutator: Sequence = new Sequence([new Commutator(\n    new Sequence([\n      BareBlockMove(\"R\",  1),\n      BareBlockMove(\"U\",  1),\n      BareBlockMove(\"R\", -2)\n    ]),\n    new Sequence([new Conjugate(\n      new Sequence([BareBlockMove(\"R\",  1)]),\n      new Sequence([BareBlockMove(\"U\",  1)]),\n      1\n    )]),\n    1\n  )]);\n\n  export const Niklas: Sequence = new Sequence([\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\",  -1),\n    BareBlockMove(\"L\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\",  -1),\n    BareBlockMove(\"U\",  -1),\n    BareBlockMove(\"L\", 1),\n    BareBlockMove(\"U\", 1)\n  ]);\n\n  export const EPerm: Sequence = new Sequence([\n    BareBlockMove(\"x\", -1),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", -1)])\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1\n    ),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", 1)])\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1\n    ),\n    BareBlockMove(\"x\", 1)\n  ]);\n\n  export const FURURFCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\",  1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"U\",  1)]),\n      new Sequence([BareBlockMove(\"R\",  1)]),\n      1\n    )]),\n    1\n  )]);\n\n  export const APermCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"R\", 2)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"F\", 2)]),\n      new Sequence([\n        BareBlockMove(\"R\", -1),\n        BareBlockMove(\"B\", -1),\n        BareBlockMove(\"R\", 1),\n      ]),\n      1\n    )]),\n    1\n  )]);\n\n  export const FURURFMoves: Sequence = new Sequence([\n    BareBlockMove(\"F\",  1),\n    BareBlockMove(\"U\",  1),\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1)\n  ]);\n\n  export const TPerm: Sequence = new Sequence([\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\",  1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\",  1),\n    BareBlockMove(\"R\",  2),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\",  1),\n    BareBlockMove(\"U\",  1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1)\n  ]);\n\n\n  export const HeadlightSwaps: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      3\n    )]),\n    1\n  )]);\n\n\n  export const TriplePause: Sequence = new Sequence([\n      new Pause(),\n      new Pause(),\n      new Pause(),\n    ]\n  );\n\n\n  export const AllAlgParts: AlgPart[] = [\n    new Sequence([BareBlockMove(\"R\", 1), BareBlockMove(\"U\", -1)]),\n    new Group(new Sequence([BareBlockMove(\"F\", 1)]), 2),\n    // new Rotation(\"y\", -1),\n    BareBlockMove(\"R\", 2),\n    new Commutator(new Sequence([BareBlockMove(\"R\", 2)]), new Sequence([BareBlockMove(\"U\", 2)]), 2),\n    new Conjugate(new Sequence([BareBlockMove(\"L\", 2)]), new Sequence([BareBlockMove(\"D\", -1)]), 2),\n    new Pause(),\n    new NewLine(),\n    new CommentShort(\"short comment\"),\n    new CommentLong(\"long comment\")\n  ];\n\n}\n","import {\n  Unit,\n  Sequence,\n  Group,\n  BlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\n// TODO: Turn this into a union.\nexport interface AlgJSON {\n  type: string;\n  nestedSequence?: AlgJSON;\n  nestedUnits?: AlgJSON[];\n  innerLayer?: number;\n  outerLayer?: number;\n  family?: string;\n  amount?: number;\n  A?: AlgJSON;\n  B?: AlgJSON;\n  comment?: string;\n}\n\nexport function fromJSON(json: AlgJSON): Sequence {\n  if (json.type !== \"sequence\") {\n    throw `Expected Sequence while parsing, got: ${json.type}`\n  }\n  if (!json.nestedUnits) { throw \"Missing nestedUnits\" }\n  return new Sequence(json.nestedUnits.map(j => unitFromJSON(j)));\n}\n\nfunction unitFromJSON(json: AlgJSON): Unit {\n  switch (json.type) {\n    case \"sequence\":\n      throw `Expected AlgPart while parsing, got \\`Sequence\\`.`\n    case \"group\":\n      if (!json.nestedSequence) { throw \"Missing nestedSequence\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Group(fromJSON(json.nestedSequence), json.amount);\n    case \"blockMove\":\n      // TODO: Double-check that there is no outer layer without an inner layer?\n      if (!json.family) { throw \"Missing family\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new BlockMove(json.outerLayer, json.innerLayer, json.family, json.amount);\n    case \"commutator\":\n      if (!json.A) { throw \"Missing A\" }\n      if (!json.B) { throw \"Missing B\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"conjugate\":\n      if (!json.A) { throw \"Missing A\" }\n      if (!json.B) { throw \"Missing B\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"pause\":\n      return new Pause();\n    case \"newLine\":\n      return new NewLine();\n    case \"commentShort\":\n      if (!json.comment) { throw \"Missing comment\" }\n      return new CommentShort(json.comment);\n    case \"commentLong\":\n      if (!json.comment) { throw \"Missing comment\" }\n      return new CommentLong(json.comment);\n    default:\n      throw `Unknown alg type: ${json.type}`;\n  }\n}\n","import {Sequence} from \"./algorithm\"\nimport {fromJSON} from \"./json\"\nimport {parse as jison_parse} from \"./jison_parser\";\nimport {Validator, validateSiGNAlg} from \"./validation\"\n\nexport type ParseOptions = {\n  validators?: Validator[]\n}\n\n// TODO: Include token location info.\n// TODO: Take validators in a way that allows optimizing parsing.\nexport function parse(s: string, options: ParseOptions = {validators: []}): Sequence {\n  options.validators = options.validators || [];\n\n  const algo = fromJSON(jison_parse(s));\n  for (const validate of options.validators) {\n    validate(algo);\n  }\n  return algo;\n}\n\nexport function parseSiGN(s: string): Sequence {\n  return parse(s, {validators: [validateSiGNAlg]});\n}\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar index = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,14],$V1=[1,5],$V2=[5,23,24,25,27],$V3=[1,23],$V4=[1,18],$V5=[1,19],$V6=[1,22],$V7=[1,16],$V8=[1,17],$V9=[1,12],$Va=[1,13],$Vb=[5,7,12,13,15,21,23,24,25,26,27,30,31],$Vc=[5,19,23,24,25,27],$Vd=[5,12,13,19,23,24,25,27,30,31],$Ve=[5,7,12,13,15,19,21,23,24,25,26,27,30,31],$Vf=[5,7,10,12,13,19,23,24,25,27,30,31],$Vg=[7,12,13,15,21,24,26,30,31];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"TOP_LEVEL_ALG\":4,\"EOF\":5,\"LAYER\":6,\"NUMBER\":7,\"REPETITION\":8,\"AMOUNT\":9,\"PRIME\":10,\"COMMENT\":11,\"COMMENT_SHORT\":12,\"COMMENT_LONG\":13,\"FAMILY\":14,\"LONG_FAMILY\":15,\"BLOCK_MOVE\":16,\"DASH\":17,\"OPTIONAL_WHITESPACE\":18,\"WHITESPACE\":19,\"REPEATABLE_UNIT\":20,\"OPEN_BRACKET\":21,\"SEQUENCE\":22,\"COMMA\":23,\"CLOSE_BRACKET\":24,\"COLON\":25,\"OPEN_PARENTHESIS\":26,\"CLOSE_PARENTHESIS\":27,\"REPEATED_UNIT\":28,\"ANNOTATION\":29,\"NEWLINE\":30,\"PAUSE\":31,\"UNIT_LIST_WITHOUT_WHITESPACE\":32,\"UNIT_LIST\":33,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"NUMBER\",10:\"PRIME\",12:\"COMMENT_SHORT\",13:\"COMMENT_LONG\",15:\"LONG_FAMILY\",17:\"DASH\",19:\"WHITESPACE\",21:\"OPEN_BRACKET\",23:\"COMMA\",24:\"CLOSE_BRACKET\",25:\"COLON\",26:\"OPEN_PARENTHESIS\",27:\"CLOSE_PARENTHESIS\",30:\"NEWLINE\",31:\"PAUSE\"},\nproductions_: [0,[3,2],[6,1],[8,1],[9,1],[9,2],[9,1],[11,1],[11,1],[14,1],[16,1],[16,2],[16,4],[18,2],[18,0],[20,1],[20,5],[20,5],[20,3],[20,1],[20,5],[20,5],[20,3],[28,1],[28,2],[29,1],[29,1],[29,1],[32,1],[32,3],[32,2],[32,2],[32,1],[33,1],[33,3],[22,3],[22,1],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n return $$[$0-1]; \nbreak;\ncase 2: case 3:\nthis.$ = parseInt($$[$0]);\nbreak;\ncase 5:\nthis.$ = -$$[$0-1];\nbreak;\ncase 6:\nthis.$ = -1;\nbreak;\ncase 7:\nthis.$ = {type: \"commentShort\", comment: $$[$0].slice(2)};\nbreak;\ncase 8:\nthis.$ = {type: \"commentLong\", comment: $$[$0].slice(2, -2)};\nbreak;\ncase 10:\nthis.$ = {type: \"blockMove\", family: $$[$0]};\nbreak;\ncase 11:\nthis.$ = {type: \"blockMove\", family: $$[$0], innerLayer: $$[$0-1]};\nbreak;\ncase 12:\nthis.$ = {type: \"blockMove\", family: $$[$0], outerLayer: $$[$0-3], innerLayer: $$[$0-1]};\nbreak;\ncase 16: case 20:\nthis.$ = {\"type\": \"commutator\", \"A\": $$[$0-3], \"B\": $$[$0-1]};\nbreak;\ncase 17: case 21:\nthis.$ = {\"type\": \"conjugate\", \"A\": $$[$0-3], \"B\": $$[$0-1]};\nbreak;\ncase 18: case 22:\nthis.$ = {\"type\": \"group\", \"nestedSequence\": $$[$0-1]};\nbreak;\ncase 23:\n$$[$0].amount = 1; this.$ = $$[$0];\nbreak;\ncase 24:\n$$[$0-1].amount = $$[$0]; this.$ = $$[$0-1];\nbreak;\ncase 25:\nthis.$ = {\"type\": \"newLine\"};\nbreak;\ncase 26:\nthis.$ = {\"type\": \"pause\"};\nbreak;\ncase 28: case 32:\nthis.$ = [$$[$0]];\nbreak;\ncase 29:\nthis.$ = $$[$0-2].concat([$$[$0-1]]).concat($$[$0]);\nbreak;\ncase 30:\nthis.$ = [$$[$0-1]].concat($$[$0]);\nbreak;\ncase 31:\nthis.$ = $$[$0-1].concat([$$[$0]]);\nbreak;\ncase 33: case 37:\nthis.$ = $$[$0];\nbreak;\ncase 34:\nthis.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 35:\nthis.$ = {\"type\": \"sequence\", \"nestedUnits\": $$[$0-1]};\nbreak;\ncase 36:\nthis.$ = {\"type\": \"sequence\", \"nestedUnits\": []};\nbreak;\n}\n},\ntable: [o([5,7,12,13,15,21,26,30,31],$V0,{3:1,4:2,22:3,18:4,19:$V1}),{1:[3]},{5:[1,6]},{5:[2,37]},o($V2,[2,36],{33:7,32:8,28:9,29:10,20:11,11:14,16:15,14:20,6:21,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vb,$V0,{18:24,19:$V1}),{1:[2,1]},o($V2,$V0,{18:25,19:[1,26]}),o($Vc,[2,33],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,28]),o($Vc,[2,32],{28:9,29:10,20:11,11:14,16:15,14:20,6:21,32:28,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vd,[2,23],{9:29,8:30,7:[1,32],10:[1,31]}),o($Ve,[2,25]),o($Ve,[2,26]),o($Ve,[2,27]),o($Vf,[2,15]),o([7,12,13,15,21,23,25,26,30,31],$V0,{18:4,22:33,19:$V1}),o([7,12,13,15,21,26,27,30,31],$V0,{18:4,22:34,19:$V1}),o($Ve,[2,7]),o($Ve,[2,8]),o($Vf,[2,10]),{14:35,15:$V6,17:[1,36]},o($Vf,[2,9]),o([15,17],[2,2]),o($Vb,[2,13]),o($V2,[2,35]),o($V2,$V0,{28:9,29:10,20:11,11:14,16:15,14:20,6:21,18:24,32:37,7:$V3,12:$V4,13:$V5,15:$V6,19:$V1,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vc,[2,31],{28:9,29:10,20:11,11:14,16:15,14:20,6:21,32:38,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vc,[2,30],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,24]),o($Vd,[2,4],{10:[1,39]}),o($Vd,[2,6]),o([5,10,12,13,19,23,24,25,27,30,31],[2,3]),{23:[1,40],25:[1,41]},{27:[1,42]},o($Vf,[2,11]),{6:43,7:$V3},o($Vc,[2,34],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vc,[2,29],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,5]),o($Vg,$V0,{18:4,22:44,19:$V1}),o($Vg,$V0,{18:4,22:45,19:$V1}),o($Vf,[2,18]),{14:46,15:$V6},{24:[1,47]},{24:[1,48]},o($Vf,[2,12]),o($Vf,[2,16]),o($Vf,[2,17])],\ndefaultActions: {3:[2,37],6:[2,1]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return \"WHITESPACE\"\nbreak;\ncase 1:return \"NUMBER\"\nbreak;\ncase 2:return \"DASH\"\nbreak;\ncase 3:return \"LONG_FAMILY\"\nbreak;\ncase 4:return \"PRIME\"\nbreak;\ncase 5:return \"PAUSE\"\nbreak;\ncase 6:return \"COMMENT_SHORT\"\nbreak;\ncase 7:return \"COMMENT_LONG\"\nbreak;\ncase 8:return \"NEWLINE\"\nbreak;\ncase 9:return \"OPEN_BRACKET\"\nbreak;\ncase 10:return \"CLOSE_BRACKET\"\nbreak;\ncase 11:return \"OPEN_PARENTHESIS\"\nbreak;\ncase 12:return \"CLOSE_PARENTHESIS\"\nbreak;\ncase 13:return \"COMMA\"\nbreak;\ncase 14:return \"COLON\"\nbreak;\ncase 15:return \"EOF\"\nbreak;\ncase 16:return \"INVALID\"\nbreak;\n}\n},\nrules: [/^(?:[^\\S\\r\\n]+)/,/^(?:[0-9]+)/,/^(?:-)/,/^(?:[_A-Za-z]+)/,/^(?:')/,/^(?:\\.)/,/^(?:\\/\\/[^\\n\\r]*)/,/^(?:\\/\\*[^]*?\\*\\/)/,/^(?:[\\n\\r])/,/^(?:\\[)/,/^(?:\\])/,/^(?:\\()/,/^(?:\\))/,/^(?:,)/,/^(?::)/,/^(?:$)/,/^(?:.)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = index;\nexports.Parser = index.Parser;\nexports.parse = function () { return index.parse.apply(index, arguments); };\n}\n","import {\n  Sequence,\n  Group,\n  BlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nimport {TraversalUp} from \"./traversal\"\n\nexport class ValidationError extends Error {}\n\nexport abstract class ValidatorTraversal extends TraversalUp<void> {}\n\ntype FamilyList = { [s: string]: boolean; }\n\nfunction validateFamily(family: string, allowedFamilyLists: FamilyList[]): boolean {\n  for (const list of allowedFamilyLists) {\n    if (list[family] === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Switch to `Set`?\nvar plainMoveFamilies: FamilyList = {\n  \"x\": true,\n  \"y\": true,\n  \"z\": true,\n  \"M\": true,\n  \"E\": true,\n  \"S\": true,\n  \"m\": true,\n  \"e\": true,\n  \"s\": true\n}\n\nvar singleSliceMoveFamilies: FamilyList = {\n  \"U\": true,\n  \"L\": true,\n  \"F\": true,\n  \"R\": true,\n  \"B\": true,\n  \"D\": true\n}\n\nvar wideMoveFamilies: FamilyList = {\n  \"u\": true,\n  \"l\": true,\n  \"f\": true,\n  \"r\": true,\n  \"b\": true,\n  \"d\": true,\n  \"Uw\": true,\n  \"Lw\": true,\n  \"Fw\": true,\n  \"Rw\": true,\n  \"Bw\": true,\n  \"Dw\": true\n}\n\nabstract class BaseMoveValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n  }\n  public traverseGroup(group: Group): void {\n    return this.traverse(group.nestedSequence);\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    this.traverse(commutator.A);\n    this.traverse(commutator.B);\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    this.traverse(conjugate.A);\n    this.traverse(conjugate.B);\n  }\n  public traversePause(pause: Pause):                      void { return; }\n  public traverseNewLine(newLine: NewLine):                void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong):    void { return; }\n}\n\n// TODO: Export function instead?\nexport class BlockMoveValidator extends BaseMoveValidator {\n  public traverseBlockMove(blockMove: BlockMove): void {\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      if (typeof blockMove.innerLayer === \"undefined\") {\n        throw new ValidationError(\"A BlockMove with an outer layer must have an inner layer.\");\n      }\n      if (!validateFamily(blockMove.family, [wideMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${blockMove.family}`);\n      }\n      if (blockMove.outerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an outer layer of 0 or less.\");\n      }\n      // TODO: Allow 2-2r?\n      if (blockMove.outerLayer >= blockMove.innerLayer) {\n        throw new ValidationError(\"The outer layer must be less than the inner layer.\");\n      }\n      return;\n    } else if (typeof blockMove.innerLayer !== \"undefined\") {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an inner slice: ${blockMove.family}`);\n      }\n      if (blockMove.innerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an inner layer of 0 or less.\");\n      }\n      return;\n    } else {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies, plainMoveFamilies])) {\n          throw new ValidationError(`Invalid SiGN plain move family: ${blockMove.family}`);\n      }\n      return;\n    }\n  }\n}\n\n// TODO: Export function instead?\nexport class FlatAlgValidator extends ValidatorTraversal {\n\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n    return;\n  }\n  public traverseGroup(group: Group): void {\n    throw new ValidationError(\"A flat alg cannot contain a group.\");\n  }\n  public traverseBlockMove(blockMove: BlockMove): void {\n    return;\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    throw new ValidationError(\"A flat alg cannot contain a commutator.\");\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    throw new ValidationError(\"A flat alg cannot contain a conjugate.\");\n  }\n  public traversePause(pause: Pause):                      void { return; }\n  public traverseNewLine(newLine: NewLine):                void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong):    void { return; }\n}\n\nexport type Validator = (a: Sequence) => void;\n\nconst BlockMoveValidatorInstance = new BlockMoveValidator();\nexport const validateSiGNMoves = <Validator>BlockMoveValidatorInstance.traverse.bind(BlockMoveValidatorInstance);\n\nconst flatAlgValidatorInstance = new FlatAlgValidator();\nexport const validateFlatAlg = <Validator>flatAlgValidatorInstance.traverse.bind(flatAlgValidatorInstance);\n\n// TODO: Option for puzzle size?\nexport const validateSiGNAlg = function(a: Sequence) {\n  validateSiGNMoves(a);\n  validateFlatAlg(a);\n}\n","import {BlockMove, BareBlockMove} from \"./algorithm\"\n\nconst cubeKeyMapping: {[key: number]: BlockMove} = {\n  73: BareBlockMove(\"R\"), 75: BareBlockMove(\"R\", -1),\n  87: BareBlockMove(\"B\"), 79: BareBlockMove(\"B\", -1),\n  83: BareBlockMove(\"D\"), 76: BareBlockMove(\"D\", -1),\n  68: BareBlockMove(\"L\"), 69: BareBlockMove(\"L\", -1),\n  74: BareBlockMove(\"U\"), 70: BareBlockMove(\"U\", -1),\n  72: BareBlockMove(\"F\"), 71: BareBlockMove(\"F\", -1), // Heise\n  78: BareBlockMove(\"F\"), 86: BareBlockMove(\"F\", -1), //Kirjava\n\n  67: BareBlockMove(\"l\"), 82: BareBlockMove(\"l\", -1),\n  85: BareBlockMove(\"r\"), 77: BareBlockMove(\"r\", -1),\n\n  84: BareBlockMove(\"x\"), 89: BareBlockMove(\"x\"), 66: BareBlockMove(\"x\", -1), // 84 (T) and 89 (Y) are alternatives.\n  186: BareBlockMove(\"y\"), 59: BareBlockMove(\"y\"), 65: BareBlockMove(\"y\", -1), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: BareBlockMove(\"z\"), 81: BareBlockMove(\"z\", -1),\n\n  190: BareBlockMove(\"M\", -1),\n}\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): BlockMove | null {\n  if(e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import {Sequence} from \"./algorithm\"\nimport {algToString} from \"./traversal\"\nimport {parse} from \"./parser\"\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nexport function serializeURLParam(a: Sequence): string {\n  var escaped = algToString(a);\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport function deserializeURLParam(a: string): Sequence {\n  var unescaped = a;\n  unescaped = unescaped.replace(/-/g, \"'\").replace(/&#45;/g, \"-\");\n  unescaped = unescaped.replace(/\\+/g, \" \").replace(/&#2b;/g, \"+\"); // Recognize + as space. Many URL encodings will do this.\n  unescaped = unescaped.replace(/_/g, \" \").replace(/&#95;/g, \"_\");\n  return parse(unescaped);\n}\n\n// Returns an empty sequence if the parameter is not present.\n// Throws an error if an alg is present but not valid.\nexport function getAlgURLParam(name: string): Sequence {\n  const s = new URLSearchParams(window.location.search).get(name) || \"\";\n  return deserializeURLParam(s);\n}\n\nexport type AlgCubingNetOptions = {\n  alg?: Sequence;\n  setup?: Sequence;\n  title?: string;\n  puzzle?: \"1x1x1\" | \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"14x14x14\" | \"16x16x16\" | \"17x17x17\";\n  stage?: \"full\" | \"cross\" | \"F2L\" | \"LL\" | \"OLL\" | \"PLL\" | \"CLS\" | \"ELS\" | \"L6E\" | \"CMLL\" | \"WV\" | \"ZBLL\" | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\"\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\"\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions) {\n  var url = new URL(\"https://alg.cubing.net\")\n  if (!options.alg) {\n    throw (\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if ([\"1x1x1\", \"2x2x2\", \"3x3x3\", \"4x4x4\", \"5x5x5\", \"6x6x6\", \"7x7x7\", \"8x8x8\", \"9x9x9\", \"10x10x10\", \"11x11x11\", \"12x12x12\", \"13x13x13\", \"14x14x14\", \"16x16x16\", \"17x17x17\"].indexOf(options.puzzle) === -1) {\n      throw `Invalid puzzle parameter: ${options.puzzle}`\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if ([\"full\", \"cross\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"CLS\", \"ELS\", \"L6E\", \"CMLL\", \"WV\", \"ZBLL\", \"void\"].indexOf(options.stage) === -1) {\n      throw `Invalid stage parameter: ${options.stage}`\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if ([\"editor\", \"playback\", \"fullscreen\"].indexOf(options.view) === -1) {\n      throw `Invalid view parameter: ${options.view}`\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if ([\"moves\", \"reconstruction\", \"alg\", \"reconstruction-end-with-setup\"].indexOf(options.type) === -1) {\n      throw `Invalid type parameter: ${options.type}`\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n"],"sourceRoot":""}